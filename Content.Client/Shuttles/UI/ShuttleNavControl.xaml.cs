using System.Numerics;
using Content.Client.Crescent.Radar;
using Content.Client.Station;
using Content.Shared._Crescent.ShipShields;
using Content.Shared.Crescent.Radar; // Frontier
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using JetBrains.Annotations;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Collision.Shapes;
using Robust.Shared.Physics.Components;
using Robust.Shared.Physics.Systems;


namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
public sealed partial class ShuttleNavControl : BaseShuttleControl
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    [Dependency] private readonly IUserInterfaceManager _uiManager = default!;
    private readonly StationSystem _station; // Frontier
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _transform;
    private readonly ProjectileIFFSystem _projectileIFF;
    private readonly FixtureSystem _fixtures;

    /// <summary>
    /// Used to transform all of the radar objects. Typically is a shuttle console parented to a grid.
    /// </summary>
    private EntityCoordinates? _coordinates;

    private Angle? _rotation;

    private Dictionary<NetEntity, List<DockingPortState>> _docks = new();
    private List<ProjectileState> _projectiles = new();
    private Dictionary<NetEntity, List<TurretState>> _turrets = new();

    internal int updateTicker = 0;



    public bool ShowIFF { get; set; } = true;
    public bool ShowDocks { get; set; } = true;

    /// <summary>
    /// Raised if the user left-clicks on the radar control with the relevant entitycoordinates.
    /// </summary>
    public Action<EntityCoordinates>? OnRadarClick;
    public Action? OnRadarRelease;
    public Action<EntityCoordinates>? OnRadarMouseMove;
    public Action<Angle>? OnRadarMouseMoveRelative;
    // Represents where the mouse would physically be in the game world. Only updates when the mouse is over the UI.
    private Vector2 MousePosition = Vector2.Zero;
    // Same as the mouse position , but this has its position constantly updated as the ship moves / rotates.
    private Vector2 RelativeMousePosition = Vector2.Zero;
    private Angle LastRotation = Angle.Zero;
    private Vector2 LastWorldCoordinates = Vector2.Zero;
    public bool keepWorldAligned = false;

    private List<Entity<MapGridComponent>> _grids = new();

    public ShuttleNavControl() : base(64f, 256f, 256f)
    {
        RobustXamlLoader.Load(this);
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _transform = EntManager.System<SharedTransformSystem>();
        _station = EntManager.System<StationSystem>(); // Frontier
        _projectileIFF = EntManager.System<ProjectileIFFSystem>();
        _fixtures = EntManager.System<FixtureSystem>();
    }

    public void SetMatrix(EntityCoordinates? coordinates, Angle? angle)
    {
        _coordinates = coordinates;
        _rotation = angle;
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (_coordinates == null || _rotation == null || args.Function != EngineKeyFunctions.UIClick ||
            OnRadarClick == null)
        {
            return;
        }

        var a = InverseScalePosition(args.RelativePosition);
        var relativeWorldPos = new Vector2(a.X, -a.Y);
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        var coords = _coordinates.Value.Offset(relativeWorldPos);
        OnRadarClick?.Invoke(coords);
        OnRadarRelease?.Invoke();
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (_coordinates == null || _rotation == null || args.Function != EngineKeyFunctions.UIClick)
            return;

        OnRadarClick?.Invoke(PureRelativePosition(args.RelativePosition));
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        var returned = PureRelativePosition(args.RelativePosition);

        OnRadarMouseMove?.Invoke(returned);
        OnRadarMouseMoveRelative?.Invoke(RelativeAngleFromFace(returned));
    }

    private EntityCoordinates RelativePositionToEntityCoords(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;

        var a = InverseScalePosition(pos);
        var relativeWorldPos = a with { Y = -a.Y };
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        return _coordinates.Value.Offset(relativeWorldPos);

    }
    // SPCR 2024 - This is only used for shooting ship weapons. The function above is ... not accurate
    // for objects with a width and height of 0 (aka bullets)
    public EntityCoordinates PureRelativePosition(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;
        var trueSize = Size;
        var a = ((pos - (trueSize/2))*2)/Size * ActualRadarRange;
        var relativePos = a with { Y = -a.Y };
        relativePos = _rotation.Value.RotateVec(relativePos);
        var gridRotation = _transform.GetWorldRotation(_coordinates.Value.EntityId);
        if (keepWorldAligned)
            gridRotation = Angle.Zero;
        MousePosition = gridRotation.RotateVec(relativePos) + _transform.ToMapCoordinates(_coordinates.Value).Position;
        RelativeMousePosition = MousePosition;
        return _coordinates.Value.Offset(relativePos);
    }

    public EntityCoordinates PureRelativePositionWithoutSetter(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;
        var trueSize = Size;
        var a = ((pos - (trueSize/2))*2)/Size * ActualRadarRange;
        var relativePos = a with { Y = -a.Y };
        relativePos = _rotation.Value.RotateVec(relativePos);
        return _coordinates.Value.Offset(relativePos);
    }

    // COnverts relative entity coordinates to relative angle. - on the left side , + on the right side.
    public Angle RelativeAngleFromFace(EntityCoordinates relPos)
    {
        var args = Angle.FromWorldVec(relPos.Position);
        return args < Angle.FromDegrees(0)
            ? new Angle(-(Math.PI + args.Theta))
            : (args > Angle.FromDegrees(270) ? args : (Math.PI - args));
    }

    /// <summary>
    /// Gets the entitycoordinates of where the mouseposition is, relative to the control.
    /// </summary>
    [PublicAPI]
    public EntityCoordinates GetMouseCoordinates(ScreenCoordinates screen)
    {
        if (_coordinates == null || _rotation == null)
        {
            return EntityCoordinates.Invalid;
        }

        var pos = screen.Position / UIScale - GlobalPosition;

        var a = InverseScalePosition(pos);
        var relativeWorldPos = new Vector2(a.X, -a.Y);
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        var coords = _coordinates.Value.Offset(relativeWorldPos);
        return coords;
    }

    public void UpdateState(IFFInterfaceState state)
    {
        _projectiles = state.Projectiles;
        _turrets = state.Turrets;
    }

    public void UpdateState(NavInterfaceState state)
    {
        SetMatrix(EntManager.GetCoordinates(state.Coordinates), new Angle(state.Angle));
        keepWorldAligned = state.AlignToWorld;
        if (keepWorldAligned)
        {
            _rotation = Angle.Zero;
        }
        WorldMaxRange = state.MaxRange;

        if (WorldMaxRange < WorldRange)
        {
            ActualRadarRange = WorldMaxRange;
        }

        if (WorldMaxRange < WorldMinRange)
            WorldMinRange = WorldMaxRange;

        ActualRadarRange = Math.Clamp(ActualRadarRange, WorldMinRange, WorldMaxRange);

        _docks = state.Docks;

        NfUpdateState(state); // Frontier Update State
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        DrawBacking(handle);
        DrawCircles(handle);

        // No data
        if (_coordinates == null || _rotation == null)
        {
            return;
        }

        updateTicker++;

        var xformQuery = EntManager.GetEntityQuery<TransformComponent>();
        var fixturesQuery = EntManager.GetEntityQuery<FixturesComponent>();
        var bodyQuery = EntManager.GetEntityQuery<PhysicsComponent>();

        if (!xformQuery.TryGetComponent(_coordinates.Value.EntityId, out var xform)
            || xform.MapID == MapId.Nullspace)
        {
            return;
        }

        var mapPos = _transform.ToMapCoordinates(_coordinates.Value);
        var offset = _coordinates.Value.Position;
        var posMatrix = Matrix3Helpers.CreateTransform(offset, _rotation.Value);
        var (_, ourEntRot, ourEntMatrix) = _transform.GetWorldPositionRotationMatrix(_coordinates.Value.EntityId);
        var rot = ourEntRot + _rotation.Value;
        if (keepWorldAligned)
        {
            ourEntRot = Angle.Zero;
            ourEntMatrix = Matrix3Helpers.CreateTransform(mapPos.Position, Angle.Zero);
            posMatrix = Matrix3Helpers.CreateTransform(Vector2.One, Angle.Zero);
            offset = Vector2.Zero;
        }

        var ourWorldMatrix = Matrix3x2.Multiply(posMatrix, ourEntMatrix);
        Matrix3x2.Invert(ourWorldMatrix, out var ourWorldMatrixInvert);

        var vert = (MousePosition - mapPos.Position) ;
        // position compensation
        if (LastWorldCoordinates != Vector2.Zero)
        {
            MousePosition += mapPos.Position - LastWorldCoordinates;
        }
        // rotational compensation
        if (LastRotation != Angle.Zero)
        {
            MousePosition = mapPos.Position + (ourEntRot - LastRotation).RotateVec(MousePosition - mapPos.Position);
        }

        LastRotation = ourEntRot;

        vert.Y = -vert.Y;
        vert = rot.RotateVec(vert);
        vert = ScalePosition(vert);
        if(updateTicker > 10)
            OnRadarMouseMove?.Invoke(PureRelativePositionWithoutSetter(vert));
        LastWorldCoordinates = mapPos.Position;
        //vert = (Angle.FromDegrees(180) - ourEntRot).RotateVec(vert);
        //Logger.Debug($"{vert.X} , {vert.Y}");

        handle.DrawCircle(vert, 5f, Color.White, false);
        if (!keepWorldAligned)
        {
            var northRot = ourEntRot + _rotation.Value;
            DrawNorthLine(handle, northRot);
        }

        var movementVector = bodyQuery.GetComponent(_coordinates.Value.EntityId).LinearVelocity;
        movementVector.Y *= -1;
        movementVector = ourEntRot.RotateVec(movementVector);
        movementVector = ScalePosition(movementVector);

        handle.DrawLine(MidPointVector, movementVector, Color.Red);

        // Draw our grid in detail
        var ourGridId = xform.GridUid;
        if (EntManager.TryGetComponent<MapGridComponent>(ourGridId, out var ourGrid) &&
            fixturesQuery.HasComponent(ourGridId.Value))
        {
            var ourGridMatrix = _transform.GetWorldMatrix(ourGridId.Value);
            var matrix = Matrix3x2.Multiply(ourGridMatrix, ourWorldMatrixInvert);
            var color = _shuttles.GetIFFColor(ourGridId.Value, self: true);

            DrawGrid(handle, matrix, (ourGridId.Value, ourGrid), color);
            DrawDocks(handle, ourGridId.Value, matrix);
            DrawTurrets(handle, ourGridId.Value, matrix, true);
        }

        DrawProjectiles(handle, ourWorldMatrixInvert);
        DrawShields(handle, xform, ourWorldMatrixInvert);


        var invertedPosition = _coordinates.Value.Position - offset;
        invertedPosition.Y = -invertedPosition.Y;
        // Don't need to transform the InvWorldMatrix again as it's already offset to its position.

        // Draw radar position on the station
        var radarPos = invertedPosition;
        const float radarVertRadius = 2f;

        var radarPosVerts = new Vector2[]
        {
            ScalePosition(radarPos + new Vector2(0f, -radarVertRadius)),
            ScalePosition(radarPos + new Vector2(radarVertRadius / 2f, 0f)),
            ScalePosition(radarPos + new Vector2(0f, radarVertRadius)),
            ScalePosition(radarPos + new Vector2(radarVertRadius / -2f, 0f)),
        };

        handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, radarPosVerts, Color.Lime);

        var viewBounds = new Box2Rotated(new Box2(-WorldRange, -WorldRange, WorldRange, WorldRange).Translated(mapPos.Position), rot, mapPos.Position);
        var viewAABB = viewBounds.CalcBoundingBox();

        _grids.Clear();
        _mapManager.FindGridsIntersecting(xform.MapID, new Box2(mapPos.Position - MaxRadarRangeVector, mapPos.Position + MaxRadarRangeVector), ref _grids, approx: true, includeMap: false);

        // Draw other grids... differently
        foreach (var grid in _grids)
        {
            var gUid = grid.Owner;
            if (gUid == ourGridId || !fixturesQuery.HasComponent(gUid))
                continue;

            var gridBody = bodyQuery.GetComponent(gUid);
            EntManager.TryGetComponent<IFFComponent>(gUid, out var iff);

            if (!_shuttles.CanDraw(gUid, gridBody, iff))
                continue;

            var gridMatrix = _transform.GetWorldMatrix(gUid);
            var matty = Matrix3x2.Multiply(gridMatrix, ourWorldMatrixInvert);
            var color = _shuttles.GetIFFColor(grid, self: false, iff);

            // Others default:
            // Color.FromHex("#FFC000FF")
            // Hostile default: Color.Firebrick
            var labelName = _shuttles.GetIFFLabel(grid, self: false, iff);
            var gridBounds = grid.Comp.LocalAABB;

            // Detailed view
            var gridAABB = gridMatrix.TransformBox(grid.Comp.LocalAABB);

            if (!gridAABB.Intersects(viewAABB) && labelName != null && ShowIFF)
            {
                const float ShipSelectionDotRadius = 5f;
                // transform vector from worldPosition to UIPosition.
                Vector2 UIPosVector = Vector2.Transform(_transform.GetWorldPosition(gUid) - mapPos.Position, ourWorldMatrixInvert);
                UIPosVector.Y *= -1;
                // get its direction.
                Vector2 UIDirection = UIPosVector.Normalized();
                // collision with oY axis.
                Vector2 YTargetScaled = MidPointVector + UIPosVector.Normalized() * Math.Abs((MidPoint-ShipSelectionDotRadius*2) / UIDirection.Y);
                // collision with oX axis
                Vector2 XTargetScaled = MidPointVector + UIPosVector.Normalized() * Math.Abs((MidPoint-ShipSelectionDotRadius*2) / UIDirection.X);
                // fucked up maths case!! SPCR
                if(YTargetScaled.X < ShipSelectionDotRadius*2)
                    YTargetScaled = XTargetScaled;
                if(XTargetScaled.Y < ShipSelectionDotRadius*2)
                    XTargetScaled = YTargetScaled;
                handle.DrawLine(MidPointVector, ScalePosition(UIPosVector), Color.AntiqueWhite);
                var gridCentre = Vector2.Transform(gridBody.LocalCenter, matty);
                gridCentre.Y = -gridCentre.Y;
                var distance = gridCentre.Length();
                // yes 1.0 scale is intended here.
                var labelText = Loc.GetString("shuttle-console-iff-label", ("name", labelName),
                    ("distance", $"{distance:0.0}"));
                var labelDimensions = handle.GetDimensions(Font, labelText, 1f);
                Vector2 textUiPosition = new Vector2(-labelDimensions.X / 2f,0);
                // dont waste GPU resources filling a pixel radius that won't show
                if (YTargetScaled.Length() < XTargetScaled.Length())
                {
                    if ((YTargetScaled - vert).Length() < 10 || distance < 512)
                    {
                        textUiPosition += YTargetScaled;
                        textUiPosition.X = Math.Clamp(textUiPosition.X, 0f, PixelWidth - labelDimensions.X);
                        textUiPosition.Y = Math.Clamp(
                            textUiPosition.Y - (Math.Sign(UIDirection.Y) + 1) * 10f,
                            0f,
                            PixelHeight - labelDimensions.Y);

                        handle.DrawString(Font,textUiPosition , labelText, color);
                    }
                    handle.DrawCircle(YTargetScaled, ShipSelectionDotRadius, color, true);
                }
                else
                {
                    if ((XTargetScaled - vert).Length() < 10 || distance < 512)
                    {
                        textUiPosition += XTargetScaled;
                        textUiPosition.X = Math.Clamp(textUiPosition.X, 0f, PixelWidth - labelDimensions.X);
                        textUiPosition.Y = Math.Clamp(textUiPosition.Y, 0f, PixelHeight - labelDimensions.Y);

                        handle.DrawString(Font,textUiPosition , labelText, color);
                    }
                    handle.DrawCircle(XTargetScaled, ShipSelectionDotRadius, color, true);
                }
            }
            else
            {
                var gridCentre = Vector2.Transform(gridBody.LocalCenter, matty);
                var globalGridCentre = _transform.GetWorldPosition(gUid);
                gridCentre.Y = -gridCentre.Y;
                var distance = gridCentre.Length();
                if (ShowIFF && labelName != null)
                {
                    var labelText = Loc.GetString(
                        "shuttle-console-iff-label",
                        ("name", labelName),
                        ("distance", $"{distance:0.0}"));

                    // yes 1.0 scale is intended here.
                    var labelDimensions = handle.GetDimensions(Font, labelText, 1f);

                    // y-offset the control to always render below the grid (vertically)
                    var yOffset = Math.Max(gridBounds.Height, gridBounds.Width) * MinimapScale / 1.8f;

                    // The actual position in the UI. We offset the matrix position to render it off by half its width
                    // plus by the offset.
                    var uiPosition = ScalePosition(gridCentre) - new Vector2(labelDimensions.X / 2f, -yOffset);

                    // Look this is uggo so feel free to cleanup. We just need to clamp the UI position to within the viewport.
                    uiPosition = new Vector2(
                        Math.Clamp(uiPosition.X, 0f, PixelWidth - labelDimensions.X),
                        Math.Clamp(uiPosition.Y, 0f, PixelHeight - labelDimensions.Y));
                    handle.DrawString(Font, uiPosition, labelText, color);
                }

            DrawGrid(handle, matty, grid, color);
            DrawDocks(handle, gUid, matty);
            DrawTurrets(handle, gUid, matty, false);
            }
        }
    }

    private void DrawDocks(DrawingHandleScreen handle, EntityUid uid, Matrix3x2 matrix)
    {
        if (!ShowDocks)
            return;

        const float DockScale = 0.6f;
        var nent = EntManager.GetNetEntity(uid);

        if (_docks.TryGetValue(nent, out var docks))
        {
            foreach (var state in docks)
            {
                var position = state.Coordinates.Position;
                var uiPosition = Vector2.Transform(position, matrix);

                if (uiPosition.Length() > (WorldRange * 2f) - DockScale)
                    continue;

                var color = Color.ToSrgb(Color.Magenta);

                var verts = new[]
                {
                    Vector2.Transform(position + new Vector2(-DockScale, -DockScale), matrix),
                    Vector2.Transform(position + new Vector2(DockScale, -DockScale), matrix),
                    Vector2.Transform(position + new Vector2(DockScale, DockScale), matrix),
                    Vector2.Transform(position + new Vector2(-DockScale, DockScale), matrix),
                };

                for (var i = 0; i < verts.Length; i++)
                {
                    var vert = verts[i];
                    vert.Y = -vert.Y;
                    verts[i] = ScalePosition(vert);
                }

                handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, color.WithAlpha(0.8f));
                handle.DrawPrimitives(DrawPrimitiveTopology.LineStrip, verts, color);
            }
        }
    }
    private void DrawProjectiles(DrawingHandleScreen handle, Matrix3x2 matrix)
    {
        foreach (var projectile in _projectiles)
        {
            var visual = _projectileIFF.GetVisual(projectile.VisualTypeIndex);
            var verts = visual.GetVertice(projectile.Coordinates.Position, matrix);
            for (var i = 0; i < verts.Length; i++)
            {
                var vert = verts[i];
                vert.Y = -vert.Y;
                verts[i] = ScalePosition(vert);
            }

            var color = _projectileIFF.GetColor(projectile.ColorIndex);
            handle.DrawPrimitives(visual.Topology, verts, color);
        }
    }

    private void DrawTurrets(DrawingHandleScreen handle, EntityUid uid, Matrix3x2 matrix, bool isSelf)
    {
        const float scale = 0.8f;

        var netEntity = EntManager.GetNetEntity(uid);
        if (_turrets.TryGetValue(netEntity, out var turrets))
        {
            foreach (var turret in turrets)
            {
                var position = turret.Coordinates.Position;
                var uiPosition = Vector2.Transform(position, matrix);

                if (uiPosition.Length() > (WorldRange * 2f) - scale)
                {
                    continue;
                }

                var verts = new[]
                {
                    position + new Vector2(-scale, -scale),
                    position + new Vector2(scale, -scale),
                    position + new Vector2(scale, scale),
                    position + new Vector2(-scale, scale),
                };

                for (var i = 0; i < verts.Length; i++)
                {
                    var vert = Vector2.Transform(verts[i], matrix);
                    vert.Y = -vert.Y;
                    verts[i] = ScalePosition(vert);
                }

                Color color;
                if (!isSelf)
                {
                    color = TurretIFFComponent.DefaultColor;
                }
                else if (turret.IsControlled)
                {
                    color = TurretIFFComponent.DefaultControlledColor;
                }
                else
                {
                    color = TurretIFFComponent.DefaultSelfColor;
                }

                handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, color);
            }
        }
    }

    private void DrawShields(DrawingHandleScreen handle, TransformComponent consoleXform, Matrix3x2 matrix)
    {
        var shields = EntManager.AllEntityQueryEnumerator<ShipShieldVisualsComponent, FixturesComponent, TransformComponent>();
        while (shields.MoveNext(out var uid, out var _, out var fixtures, out var xform))
        {
            if (!EntManager.TryGetComponent<TransformComponent>(xform.GridUid, out var parentXform))
                continue;

            if (xform.MapID != consoleXform.MapID)
                continue;

            var shieldFixture = _fixtures.GetFixtureOrNull(uid, "shield", fixtures);

            if (shieldFixture == null || shieldFixture.Shape is not ChainShape)
                continue;

            ChainShape chain = (ChainShape) shieldFixture.Shape;

            var count = chain.Count;
            var verticies = chain.Vertices;

            var center = xform.LocalPosition;

            for (int i = 1; i < count; i++)
            {
                var v1 = Vector2.Add(center, verticies[i - 1]);
                v1 = Vector2.Transform(v1, parentXform.WorldMatrix); // transform to world matrix
                v1 = Vector2.Transform(v1, matrix); // get back to local matrix for drawing
                v1.Y = -v1.Y;
                v1 = ScalePosition(v1);
                var v2 = Vector2.Add(center, verticies[i]);
                v2 = Vector2.Transform(v2, parentXform.WorldMatrix);
                v2 = Vector2.Transform(v2, matrix);
                v2.Y = -v2.Y;
                v2 = ScalePosition(v2);
                handle.DrawLine(v1, v2, Color.Purple);
            }
        }
    }


    private Vector2 InverseScalePosition(Vector2 value)
    {
        return (value - MidPointVector) / MinimapScale;
    }
}
